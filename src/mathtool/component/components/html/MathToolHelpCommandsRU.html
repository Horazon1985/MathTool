<font size="6"><strong>Команды:</strong></font><br><br>

MathTool знает такие команды:<br><br>

<strong>approx(F(x<sub>1</sub>, ..., x<sub>n</sub>)):</strong> Приближает выражение F(x<sub>1</sub>, ..., x<sub>n</sub>).<br><br>

<em>Пример:</em> approx(3^0.5) возвращает<br>

<p style="text-align: center;">1.7320508075688772</p><br>

<strong>ccnf(F(x<sub>1</sub>, ..., x<sub>n</sub>)):</strong> Возвращает каноническую конюнктивную нормальную форму логического выражения F(x<sub>1</sub>, ..., x<sub>n</sub>).<br><br>

<strong>cdnf(F(x<sub>1</sub>, ..., x<sub>n</sub>)):</strong> Возвращает каноническую дизъюнктивную нормальную форму логического выражения F(x<sub>1</sub>, ..., x<sub>n</sub>).<br><br>

<strong>clear():</strong> Очищает всю консоль. При этом переменные и функции, определённные пользователем, остаются в памяти.<br><br>

<strong>def(x = x<sub>0</sub>):</strong> Присваивает переменной x константу x<sub>0</sub>.<br><br>

<strong>def(F(x<sub>1</sub>, ..., x<sub>n</sub>) = G(x<sub>1</sub>, ..., x<sub>n</sub>)):</strong> Определяет функцию F от переменных  x<sub>1</sub>, ..., x<sub>n</sub> при помощи выражения G(x<sub>1</sub>, ..., x<sub>n</sub>). Конечно наперёд заданные функции, такие как sin(), tan(), exp(), etc. не могут быть переопределены.<br><br>

<em>Пример:</em> После выполнения def(f(x, y) = x^2 + sin(x*y)), MathTool знает функцию f. Тогда f(u^3, u*v^4) возвращает<br>

<p style="text-align: center;">u^6+sin(u^4*v^4).</p><br>

<strong>defvars():</strong> Возвращает список переменных с предопределёнными значениями командой def().<br><br>

<strong>eigenvalues(A):</strong> Возвращает собственные значения квадратной матрицы A, если их возможно определить.<br><br>

<strong>eigenvectors(A):</strong> Возвращает собственные  векторы квадратной матрицы A, погруппированные по соответствующим собственным векторам, если их возможно определить. <br><br>

<strong>euler(n):</strong> Возвращает первые n разрядов константы Эйлера e. Результат <em>не</em> округляется.<br><br>

<em>Пример:</em> euler(20) возвращает<br>

<p style="text-align: center;">2.71828182845904523536</p><br>

Из соображений сохранения памяти, число n не должно превышать 100000.<br><br>

<strong>expand(F(x<sub>1</sub>, ..., x<sub>n</sub>)):</strong> Раскрывает все скобки в выражении F.<br><br>

<em>Пример:</em> expand(x+(a+b)*(c+d+e)) возвращает

<p style="text-align: center;">x+a*c+a*d+a*e+b*c+b*d+b*e</p><br>

<strong>latex(F<sub>1</sub>(x<sub>1</sub>, ..., x<sub>n</sub>) = ... = F<sub>m</sub>(x<sub>1</sub>, ..., x<sub>n</sub>)):</strong> Генерирует код Latex для математического выражения F<sub>1</sub>(x<sub>1</sub>, ..., x<sub>n</sub>) = ... = F<sub>m</sub>(x<sub>1</sub>, ..., x<sub>n</sub>).<br><br>

<strong>normal(F(x<sub>1</sub>, ..., x<sub>n</sub>), x<sub>1</sub> = a<sub>1</sub>, ..., x<sub>n</sub> = a<sub>n</sub>):</strong> Возвращает параметризацию нормали к графу F в  точке (x<sub>1</sub>, ..., x<sub>n</sub>) = (a<sub>1</sub>, ..., a<sub>n</sub>).<br><br>

<strong>pi(n):</strong> Возвращает первые n разрядов константы &#960;. Результат <em>не</em> округляется.<br><br>

<em>Пример:</em> pi(20) возвращает<br>

<p style="text-align: center;">3.14159265358979323846</p><br>

Из соображений оптимального использования памяти n не должно превышать 100000.<br><br>

<strong>plot2d(F<sub>1</sub>(x), ..., F<sub>n</sub>(x), x, x<sub>1</sub>, x<sub>2</sub>):</strong> Строит график функций F<sub>1</sub>, ..., F<sub>n</sub> для x<sub>1</sub> &lt;= x &lt;= x<sub>2</sub>. Коэффициент масштабирования может быть (почти) произвольным.<br><br>

<strong>plotimplicit2d(F<sub>1</sub>(x, y) = F<sub>2</sub>(x, y), x, y, x<sub>1</sub>, x<sub>2</sub>, y<sub>1</sub>, y<sub>2</sub>):</strong> Строит графики решений уравнения F<sub>1</sub>(x, y) = F<sub>2</sub>(x, y) двух переменных x<sub>1</sub> &lt;= x &lt;= x<sub>2</sub>, y<sub>1</sub> &lt;= y &lt;= y<sub>2</sub>. Тут масштабирование и движение системы координат невозможны.<br>

<strong>plot3d(F<sub>1</sub>(x, y), ..., F<sub>n</sub>(x, y), x, y, x<sub>1</sub>, x<sub>2</sub>, y<sub>1</sub>, y<sub>2</sub>):</strong> Строит графики функций F<sub>1</sub>, ..., F<sub>n</sub> в прямоугольнике x<sub>1</sub> &lt;= x &lt;= x<sub>2</sub>, y<sub>1</sub> &lt;= y &lt;= y<sub>2</sub>. Коэффициент масштабирования может принимать все значения между 0.1 и 10.<br><br>

<strong>plotimplicit3d(F<sub>1</sub>(x, y, z) = F<sub>2</sub>(x, y, z), x, y, z, x<sub>1</sub>, x<sub>2</sub>, y<sub>1</sub>, y<sub>2</sub>, z<sub>1</sub>, z<sub>2</sub>):</strong> Строит решение уравнения F<sub>1</sub>(x, y, z) = F<sub>2</sub>(x, y, z) в трёх переменных в кубоиде x<sub>1</sub> &lt;= x &lt;= x<sub>2</sub>, y<sub>1</sub> &lt;= y &lt;= y<sub>2</sub>, z<sub>1</sub> &lt;= z &lt;= z<sub>2</sub>. Коэффициент масштабирования может принимать все значения между 0.1 и 10.<br>

<strong>plotcurve2d([F<sub>1</sub>(t); F<sub>2</sub>(t)], t, t<sub>1</sub>, t<sub>2</sub>):</strong> Строит плоскую кривую, которая параметризированна функциями x = F<sub>1</sub>(t) и y = F<sub>2</sub>(t) для t<sub>1</sub> &lt;= t &lt;= t<sub>2</sub>. Коэффициент масштабирования может принимать все значения между 0.1 и 10. Может так случиться (если вібрать "плохую" кривую), что только одна её часть будет отображена (то есть t<sub>1</sub> &lt;= t &lt;= t' для некоторго t' &lt;= t<sub>2</sub>).<br><br>

<strong>plotcurve3d([F<sub>1</sub>(t); F<sub>2</sub>(t); F<sub>3</sub>(t)], t, t<sub>1</sub>, t<sub>2</sub>):</strong> Строит  кривую, которая параметризированна функциями x = F<sub>1</sub>(t), y = F<sub>2</sub>(t) и z = F<sub>3</sub>(t) для t<sub>1</sub> &lt;= t &lt;= t<sub>2</sub>. Коэффициент масштабирования может принимать все значения между 0.1 и 10. Может так случиться (если вібрать "плохую" кривую), точно так же как для плоских кривых, что только одна её часть будет отображена.<br><br>

<strong>plotpolar(F<sub>1</sub>(t), ..., F<sub>n</sub>(t), t, t<sub>1</sub>, t<sub>2</sub>):</strong> Строит графики функций F<sub>1</sub>, ..., F<sub>n</sub> для t<sub>1</sub> &lt;= t &lt;= t<sub>2</sub>, где t - угол и F<sub>i</sub>(t) - радиус в полярных координатах. Коэффициент масштабирования может принимать все значения между 0.1 и 10.<br><br>

<strong>plotcylindrical(F<sub>1</sub>(r, t), ..., F<sub>n</sub>(r, t), r, t, r<sub>1</sub>, r<sub>2</sub>, t<sub>1</sub>, t<sub>2</sub>):</strong> Строит графики функций F<sub>1</sub>(r, t), ..., F<sub>n</sub>(r, t) для r<sub>1</sub> &lt;= r &lt;= r<sub>2</sub> и t<sub>1</sub> &lt;= t &lt;= t<sub>2</sub> в цилиндрических координатах, где r это радиус, а t - угол. Радиус должен быть неотрицательным, разница t<sub>2</sub> - t<sub>1</sub> углов не должна превышать 20&#960; по техническим причинам. Фактор масштабирования может принимать значения между 0.1 и 10.<br><br>

<strong>plotspherical(F<sub>1</sub>(u, v), ..., F<sub>n</sub>(u, v), u, v, u<sub>1</sub>, u<sub>2</sub>, v<sub>1</sub>, v<sub>2</sub>):</strong> Строит графики функций F<sub>1</sub>(u, v), ..., F<sub>n</sub>(u, v) для u<sub>1</sub> &lt;= u &lt;= u<sub>2</sub> и v<sub>1</sub> &lt;= v &lt;= v<sub>2</sub> в цилиндрических координатах, где u это угол в x, y-плоскости и v - угол к оси z. Разницы u<sub>2</sub> - u<sub>1</sub> и v<sub>2</sub> - v<sub>1</sub> углов не должны превышать 20&#960; по техническим причинам. Фактор масштабирования может принимать значения между 0.1 и 10.<br><br>

<strong>plotsurface([F<sub>1</sub>(s, t); F<sub>2</sub>(s, t); F<sub>3</sub>(s, t)], s, t, s<sub>1</sub>, s<sub>2</sub>, t<sub>1</sub>, t<sub>2</sub>):</strong> Строит поверхность, которая задана компонентными функциями x = F<sub>1</sub>(s, t), y = F<sub>2</sub>(s, t) and z = F<sub>3</sub>(s, t) для s<sub>1</sub> &lt;= s &lt;= s<sub>2</sub> и t<sub>1</sub> &lt;= t &lt;= t<sub>2</sub>. Коэффициент масштабирования может принимать все значения между 0.1 и 10.<br><br>

<strong>plotvectorfield2d([F<sub>1</sub>(x, y); F<sub>2</sub>(x, y)], x, y, x<sub>1</sub>, x<sub>2</sub>, y<sub>1</sub>, y<sub>2</sub>):</strong> Строит векторное поле [F<sub>1</sub>(x, y); F<sub>2</sub>(x, y)] для x<sub>1</sub> &lt;= x &lt;= x<sub>2</sub> и y<sub>1</sub> &lt;= y &lt;= y<sub>2</sub>. Фактор масштабирования может быть (почти) любым.<br><br>

<strong>plotvectorfieldpolar([F<sub>1</sub>(r, t); F<sub>2</sub>(r, t)], r, t, r<sub>1</sub>, r<sub>2</sub>, t<sub>1</sub>, t<sub>2</sub>):</strong> Plots the vector field [F<sub>1</sub>(r, t); F<sub>2</sub>(r, t)] for r<sub>1</sub> &lt;= r &lt;= r<sub>2</sub> and t<sub>1</sub> &lt;= t &lt;= t<sub>2</sub>. Here, (r, t) is the polar representation of the current point and F<sub>1</sub>(r, t) is the radius and F<sub>2</sub>(r, t) the angle of the polar representation of the vector field. The zoom factor can be (almost) arbitrary.<br><br>

<strong>regressionline(P<sub>1</sub>, ..., P<sub>n</sub>):</strong> Вычисляет уравнение регрессионной прямой для точек P<sub>1</sub>, ..., P<sub>n</sub>, 2 &lt;= n, и строит её график, если это возможно. Точки P<sub>i</sub> должны быть (после упрощения) в форме [a;b], то есть должны быть (2x1)-матрицами.<br><br>

<strong>solve(F<sub>1</sub>(x) = F<sub>2</sub>(x)):</strong> Возвращает алгебраические (точные) решения уравнения F<sub>1</sub>(x) = F<sub>2</sub>(x) по переменной x, если это возможно. Например уравнение вида exp(x) - x = 3 не имеют решений, которые можна выразить алгебраически или при помощи элементарных функций. В таком случае MathTool не вернёт никаких (точных) решений.

<em>Пример:</em> Рассмотрим уравнение x^18 - 3*x^6 - 11 = 0. Команда solve(x^18 - 3*x^6 - 11 = 0) возвращает решения
<p style="text-align: center;">x_1 = ((11/2+117^(1/2)/2)^(1/3)+(11/2-117^(1/2)/2)^(1/3))^(1/6)</p>
<p style="text-align: center;">x_2 = -((11/2+117^(1/2)/2)^(1/3)+(11/2-117^(1/2)/2)^(1/3))^(1/6).</p>
В приближенном виде эти решения равны x<sub>1, 2</sub> ≈ ±1.1777403511345441. Они так же могут быть получены при использовании команды solve на подходящем интервале (смотрите ниже).<br><br>

<strong>solve(F<sub>1</sub>(x, a<sub>1</sub>, ..., a<sub>n</sub>) = F<sub>2</sub>(x, a<sub>1</sub>, ..., a<sub>n</sub>), x):</strong> Возвращает (точные) решения уравнения F<sub>1</sub>(x, a<sub>1</sub>, ..., a<sub>n</sub>) = F<sub>2</sub>(x, a<sub>1</sub>, ..., a<sub>n</sub>) по x (в зависимости от параметров a<sub>1</sub>, ..., a<sub>n</sub>), если это возможно.<br><br>

<strong>solve(F<sub>1</sub>(x) = F<sub>2</sub>(x), x<sub>1</sub>, x<sub>2</sub>):</strong> Возвращает числовые решения уравнения F<sub>1</sub>(x) = F<sub>2</sub>(x) на интервале x<sub>1</sub> &lt;= x &lt;= x<sub>2</sub>.<br><br>

<strong>solve(F<sub>1</sub>(x) = F<sub>2</sub>(x), x<sub>1</sub>, x<sub>2</sub>, n):</strong> Возвращает числовые решения уравнения F<sub>1</sub>(x) = F<sub>2</sub>(x) на интервале x<sub>1</sub> &lt;= x &lt;= x<sub>2</sub>. Тут интервал [x<sub>1</sub>, x<sub>2</sub>] разделён на n одинаковых подинтервалов, и в каждом из интервалов может быть найдено максимум одно решение. Большее n может потенциально дать больше решений, но это повышает время вычисления. Эта функция может быть полезна, если пользователь обладает некоторыми специальными знаниями об уравнении F<sub>1</sub>(x) = F<sub>2</sub>(x).<br><br>

<strong>solvediffeq(F<sub>1</sub>(x, y, y', y'', ..., y<sup>(n)</sup>) = F<sub>2</sub>(x, y, y', y'', ..., y<sup>(n)</sup>), x, y):</strong> Возвращает решения дифференциального уравнения F<sub>1</sub>(x, y, y', y'', ..., y<sup>(n)</sup>) = F<sub>2</sub>(x, y, y', y'', ..., y<sup>(n)</sup>).<br><br>

<strong>solvediffeq(F(x, y, y', y'', ..., y<sup>(n-1)</sup>), x, y, n, x<sub>0</sub>, x<sub>1</sub>, y<sub>0</sub>, y<sub>1</sub>, ..., y<sub>n-1</sub>):</strong> Возвращает числовые решения дифференциального уравнения y<sup>(n)</sup> = F(x, y, y', y'', ..., y<sup>(n-1)</sup>), y(x<sub>0</sub>) = y<sub>0</sub>, ..., y<sup>(n-1)</sup>(x<sub>0</sub>) = y<sub>n-1</sub> на интервале x_0 &lt;= x &lt;= x<sub>1</sub>. Для числовых рассчётов, интервал [x<sub>0</sub>, x<sub>1</sub>] разделяется на 1000 подинтервалов и MathTool возвращает все 1001 значения функции в соответствующих точках.<br><br>

<em>Пример:</em> solvediffeq(-y,t,y,2,0,10,1,0) вернёт числовые решения дифференциального уравнения y''(t) = -y(t), y(0) = 1, y'(0) = 0 для 0 &lt;= t &lt;= 10. Тут MathTool вернет 1001 значение y(t), поскольку прирост равен 0.01.<br><br>

<strong>table(F(x<sub>1</sub>, ..., x<sub>n</sub>)):</strong>Возвращает таблицу всех возможных значений логического выражения F(x<sub>1</sub>, ..., x<sub>n</sub>), в зависимости от значений переменных x<sub>1</sub>, ..., x<sub>n</sub>. Если n больше 20, то подсчеты проводиться не будут.<br><br>

<strong>tangent(F(x<sub>1</sub>, ..., x<sub>n</sub>), x<sub>1</sub> = a<sub>1</sub>, ..., x<sub>n</sub> = a<sub>n</sub>):</strong> Возвращает уравнение касательного пространства к графику F в точке (x<sub>1</sub>, ..., x<sub>n</sub>) = (a<sub>1</sub>, ..., a<sub>n</sub>).<br><br>
<em>Пример:</em> tangent(x^3+x/2+3,x=2) вернёт такое уравнение:<br>

<p style="text-align: center;">Y=12+(25*(x-2))/2.</p><br>

Дополнительно MathTool строит оба графика (функций x^3+x/2+3 и 12+25*(x-2)/2).<br><br>

<strong>taylordiffeq(F(x, y, y', y'', ..., y<sup>(n-1)</sup>), x, y, n, x<sub>0</sub>, y<sub>0</sub>, y<sub>1</sub>, ..., y<sub>n-1</sub>, m):</strong> Возвращает полином Тейлора степеня m решения дифференциального уравнения y<sup>(n)</sup> = F(x, y, y', y'', ..., y<sup>(n-1)</sup>), y(x<sub>0</sub>) = y_0, ..., y<sup>(n-1)</sup>(x<sub>0</sub>) = y<sub>n-1</sub>.<br><br>

<em>Пример:</em> taylordeq(-y,t,y,2,0,1,0,10) вернёт полином Тейлора степеня 10 уравнения y''(t) = -y(t), y(0) = 1, y'(0) = 0. Точное решение задано равенством y(t) = cos(t), поскольку последовательности степеней имеют следующий вид<br><br>

<p style="text-align: center;">y(t) = cos(t) = 1 - t^2/2! + t^4/4! - t^6/6! + ...</p><br>

Таким образом MathTool возвращает<br>

<p style="text-align: center;">1 + t^4/24 + t^8/40320-(t^2/2 + t^6/720 + t^10/3628800).</p><br>

<strong>undeffuncs(f<sub>1</sub>, ..., f<sub>n</sub>):</strong> Удаляет функции f<sub>1</sub>, ..., f<sub>n</sub>.<br><br>

<strong>undefvars(x<sub>1</sub>, ..., x<sub>n</sub>):</strong> Переменные x<sub>1</sub>, ..., x<sub>n</sub> снова являются свободными переменными, то есть им не присвоено никакое значение.<br><br>

<strong>undefallfuncs():</strong> Удаляет все функции определённые на протяжении сессии.<br><br>

<strong>undefallvars():</strong> Все переменные, которым было присвоено значение на протяжении этой сессии, снова становятся свободными переменными.<br><br>

<strong>undefall():</strong> Удаляет все функции и переменные определённые на протяжении сессии.<br><br>

Все консольные команды, которые были выполнены на протяжении сессии, хранятся и могут быть повторены при помощи стрелок (вверх = последняя команда, вниз = следующая команда).